<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Deriv Bot v2.0</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div id="loading" class="loading-overlay hidden">
        <div class="loading-content">
            <div class="spinner"></div>
            <p id="loadingText">Please wait...</p>
        </div>
    </div>

    <header>
        <h1>Enhanced Deriv Bot v2.0: Adaptive Intelligence</h1>
    </header>

    <main>
        <section class="controls">
            <h2>Configuration</h2>
            <div class="form-group">
                <label for="token">API Token:</label>
                <input type="text" id="token" placeholder="Enter Deriv API Token">
            </div>
            <div class="form-group">
                <label for="symbol">Symbol:</label>
                <select id="symbol">
                    <option value="R_10">Volatility 10 Index</option>
                    <option value="R_25">Volatility 25 Index</option>
                    <option value="R_50">Volatility 50 Index</option>
                    <option value="R_75">Volatility 75 Index</option>
                    <option value="R_100">Volatility 100 Index</option>
                    <!-- Add more symbols as needed -->
                </select>
            </div>
            <div class="form-group">
                <label for="granularity">Granularity (seconds):</label>
                <select id="granularity">
                    <option value="60">1 Minute</option>
                    <option value="120">2 Minutes</option>
                    <option value="180">3 Minutes</option>
                    <option value="300">5 Minutes</option>
                    <option value="600">10 Minutes</option>
                </select>
            </div>
            <div class="form-group">
                <label for="stake">Stake (USD):</label>
                <input type="number" id="stake" value="1" min="0.35" step="0.01">
            </div>
            <div class="form-group checkbox-group">
                <input type="checkbox" id="liveMode">
                <label for="liveMode">Enable Live Trading (Real Money)</label>
            </div>
            <div id="confirmLiveGroup" class="form-group checkbox-group hidden">
                <input type="checkbox" id="confirmLive">
                <label for="confirmLive">Confirm Live Trades</label>
            </div>
            <div class="button-group">
                <button id="connectBtn">Connect & Authorize</button>
                <button id="startAutoBtn" disabled>Start Auto Trading</button>
                <button id="stopAutoBtn" disabled>Stop Auto Trading</button>
                <button id="clearHistoryBtn">Clear History</button>
            </div>
        </section>

        <section class="status">
            <h2>Status</h2>
            <p id="status">Idle - Adaptive Intelligence Ready</p>
            <p id="lastUpdated">Last Updated: -</p>
            <p id="tradesCount">Trades: 0</p>
            <p id="decisionText">Decision: -</p>
        </section>

        <section class="indicators">
            <h2>Indicators & Analysis</h2>
            <ul id="indList"></ul>
        </section>

        <section class="chart">
            <h2>Candle Chart</h2>
            <canvas id="candleChart" height="400"></canvas>
        </section>

        <section class="feed">
            <h2>Activity Feed</h2>
            <div id="feed" class="feed-container"></div>
        </section>

        <section class="history">
            <h2>Trade History</h2>
            <div id="history" class="history-container"></div>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Enhanced Deriv Bot. Use at your own risk. Demo account recommended.</p>
    </footer>

    <script>
/* Enhanced Deriv Bot v2.0: Advanced Adaptive Intelligence
 - Adaptive Contextual Indicators with dynamic weighting
 - Predictive Micro-Structure Analysis for candle patterns
 - Intelligent Duration Optimization with risk-adjusted expiry
 - Machine Learning-inspired decision framework
 - Multi-dimensional market regime detection
 - Enhanced pattern recognition and confidence scoring
 - Real-time tick subscription for live updates
 - Advanced error handling and reconnection logic
 - Persistent settings via localStorage
 - Safety: Live mode requires double confirmation
*/

/* ---------- Config ---------- */
const APP_ID = 1089;
const CANDLES_COUNT = 200;
const AUTO_INTERVAL_MS = 10000;
const KEEP_ALIVE_MS = 25000;
const TICK_SUBSCRIPTION = true;

/* ---------- State ---------- */
let ws = null;
let candleData = [];
let tickBuffer = []; // For micro-structure analysis
let chart = null;
let authorized = false;
let autoTrading = false;
let autoTimer = null;
let pingTimer = null;
let tradesMade = 0;
let lastProposalReceived = null;
let accountBalance = null;
let tickSubscriptionId = null;
let settings = {};
let marketRegime = { type: 'UNKNOWN', volatility: 0, trend: 0, confidence: 0 };
let indicatorWeights = { ma: 1.0, rsi: 1.0, bb: 1.0, momentum: 1.0, volume: 1.0 };
let patternLibrary = new Map();
let performanceMetrics = { wins: 0, losses: 0, totalProfit: 0, regimeHistory: [] };

/* ---------- DOM ---------- */
const tokenInput = document.getElementById('token');
const symbolEl = document.getElementById('symbol');
const granEl = document.getElementById('granularity');
const stakeEl = document.getElementById('stake');
const connectBtn = document.getElementById('connectBtn');
const startAutoBtn = document.getElementById('startAutoBtn');
const stopAutoBtn = document.getElementById('stopAutoBtn');
const clearHistoryBtn = document.getElementById('clearHistoryBtn');
const statusEl = document.getElementById('status');
const lastUpdatedEl = document.getElementById('lastUpdated');
const feedEl = document.getElementById('feed');
const indList = document.getElementById('indList');
const decisionText = document.getElementById('decisionText');
const tradesCountEl = document.getElementById('tradesCount');
const historyEl = document.getElementById('history');
const loadingOverlay = document.getElementById('loading');
const loadingText = document.getElementById('loadingText');
const liveModeCheckbox = document.getElementById('liveMode');
const confirmLiveCheckbox = document.getElementById('confirmLive');
const confirmLiveGroup = document.getElementById('confirmLiveGroup');

/* ---------- UI Helpers ---------- */
function showLoading(text = 'Please wait...') {
    loadingText.textContent = text;
    loadingOverlay.classList.remove('hidden');
}
function hideLoading() {
    loadingOverlay.classList.add('hidden');
}
function setStatus(text, color = '') {
    statusEl.textContent = text;
    statusEl.style.color = color || 'var(--muted-color)';
}
function appendFeed(msg, type = 'info') {
    const div = document.createElement('div');
    div.className = `feed-item ${type}`;
    const time = new Date().toLocaleTimeString();
    div.innerHTML = `<span>${msg}</span><span style="color:var(--muted-color)">${time}</span>`;
    feedEl.prepend(div);
    feedEl.scrollTop = 0;
}
function saveHistoryRecord(record) {
    const hist = JSON.parse(localStorage.getItem('tradeHistory') || '[]');
    hist.unshift(record);
    localStorage.setItem('tradeHistory', JSON.stringify(hist));
    renderHistory();
    updatePerformanceMetrics(record);
}
function renderHistory() {
    const hist = JSON.parse(localStorage.getItem('tradeHistory') || '[]');
    historyEl.innerHTML = '';
    const summary = document.createElement('div');
    summary.className = 'history-summary';
    const totalProfit = hist.reduce((s, h) => s + (h.profit || 0), 0);
    const winRate = hist.length > 0 ? (hist.filter(h => h.result === 'WIN').length / hist.length * 100).toFixed(1) : 0;
    summary.innerHTML = `<strong>Total Trades:</strong> ${hist.length} â€¢ <strong>Win Rate:</strong> ${winRate}% â€¢ <strong>Total P/L:</strong> ${totalProfit.toFixed(2)} USD`;
    historyEl.appendChild(summary);
    hist.slice(0, 200).forEach(r => {
        const d = document.createElement('div');
        d.className = 'history-item';
        const profitColor = r.profit > 0 ? 'var(--success-color)' : (r.profit < 0 ? 'var(--error-color)' : 'var(--muted-color)');
        d.innerHTML = `
            <span>${r.time}</span>
            <span>${r.mode}</span>
            <span>${r.symbol}</span>
            <span>${r.decision}</span>
            <span>Stake: ${r.amount}</span>
            <span style="color: ${profitColor}">${r.result || 'PENDING'} ${r.profit !== undefined ? '(' + r.profit.toFixed(2) + ')' : ''}</span>
        `;
        historyEl.appendChild(d);
    });
    tradesCountEl.textContent = `Trades: ${hist.length}`;
}
function clearHistory() {
    if (confirm('Clear all trade history?')) {
        localStorage.removeItem('tradeHistory');
        performanceMetrics = { wins: 0, losses: 0, totalProfit: 0, regimeHistory: [] };
        renderHistory();
        appendFeed('Trade history cleared', 'warn');
    }
}
function updateBalanceDisplay() {
    if (accountBalance !== null) {
        setStatus(`Authorized | Balance: ${accountBalance.toFixed(2)} USD | Regime: ${marketRegime.type}`, 'var(--success-color)');
    }
}

/* ---------- Advanced Math & Indicators ---------- */
function calcMA(values, period = 14) {
    const res = [];
    for (let i = 0; i < values.length; i++) {
        if (i < period - 1) {
            res.push(null);
            continue;
        }
        const slice = values.slice(i - period + 1, i + 1);
        res.push(slice.reduce((a, b) => a + b, 0) / period);
    }
    return res;
}

function calcEMA(values, period = 14) {
    const res = [];
    const k = 2 / (period + 1);
    for (let i = 0; i < values.length; i++) {
        if (i === 0) {
            res.push(values[i]);
        } else {
            res.push(values[i] * k + res[i - 1] * (1 - k));
        }
    }
    return res;
}

function calcRSI(values, period = 14) {
    if (values.length <= period) return Array(values.length).fill(null);
    const gains = [], losses = [];
    for (let i = 1; i < values.length; i++) {
        const d = values[i] - values[i - 1];
        gains.push(Math.max(0, d));
        losses.push(Math.max(0, -d));
    }
    const rsi = Array(values.length).fill(null);
    let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
    let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
    rsi[period] = avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss));
    for (let i = period + 1; i < values.length; i++) {
        const g = gains[i - 1], l = losses[i - 1];
        avgGain = (avgGain * (period - 1) + g) / period;
        avgLoss = (avgLoss * (period - 1) + l) / period;
        rsi[i] = avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss));
    }
    return rsi;
}

function calcBollinger(values, period = 20, mult = 2) {
    const res = [];
    for (let i = 0; i < values.length; i++) {
        if (i < period - 1) {
            res.push({ upper: null, middle: null, lower: null });
            continue;
        }
        const slice = values.slice(i - period + 1, i + 1);
        const mean = slice.reduce((a, b) => a + b, 0) / period;
        const variance = slice.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / period;
        const std = Math.sqrt(variance);
        res.push({ upper: mean + mult * std, middle: mean, lower: mean - mult * std });
    }
    return res;
}

function calcVolatility(closes, period = 20) {
    if (closes.length < period) return 0;
    const slice = closes.slice(-period);
    const mean = slice.reduce((a, b) => a + b, 0) / period;
    const variance = slice.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / period;
    return Math.sqrt(variance);
}

function calcMACD(values, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
    const emaFast = calcEMA(values, fastPeriod);
    const emaSlow = calcEMA(values, slowPeriod);
    const macdLine = emaFast.map((f, i) => f - emaSlow[i]);
    const signalLine = calcEMA(macdLine, signalPeriod);
    const histogram = macdLine.map((m, i) => m - signalLine[i]);
    return { macdLine, signalLine, histogram };
}

function calcATR(candles, period = 14) {
    if (candles.length < period + 1) return Array(candles.length).fill(null);
    const tr = [];
    for (let i = 1; i < candles.length; i++) {
        const high = candles[i].high;
        const low = candles[i].low;
        const prevClose = candles[i - 1].close;
        tr.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
    }
    const atr = [null];
    let sum = tr.slice(0, period).reduce((a, b) => a + b, 0);
    atr.push(sum / period);
    for (let i = period; i < tr.length; i++) {
        atr.push((atr[atr.length - 1] * (period - 1) + tr[i]) / period);
    }
    return atr;
}

/* ---------- Market Regime Detection ---------- */
function detectMarketRegime(candles) {
    if (candles.length < 50) return { type: 'INSUFFICIENT_DATA', volatility: 0, trend: 0, confidence: 0 };
    
    const closes = candles.map(c => c.close);
    const volatility = calcVolatility(closes, 20);
    const ma20 = calcMA(closes, 20);
    const ma50 = calcMA(closes, 50);
    const atr = calcATR(candles, 14);
    
    const currentPrice = closes[closes.length - 1];
    const ma20Current = ma20[ma20.length - 1];
    const ma50Current = ma50[ma50.length - 1];
    const atrCurrent = atr[atr.length - 1];
    
    // Trend calculation
    const trendStrength = ma20Current && ma50Current ? (ma20Current - ma50Current) / ma50Current : 0;
    const priceVsMA = ma20Current ? (currentPrice - ma20Current) / ma20Current : 0;
    
    // Volatility classification
    const volPercentage = volatility / currentPrice;
    const isHighVol = volPercentage > 0.01;
    const isLowVol = volPercentage < 0.003;
    
    // Regime determination
    let regimeType = 'NEUTRAL';
    let confidence = 0.5;
    
    if (Math.abs(trendStrength) > 0.02 && !isLowVol) {
        regimeType = trendStrength > 0 ? 'STRONG_UPTREND' : 'STRONG_DOWNTREND';
        confidence = 0.85;
    } else if (Math.abs(trendStrength) > 0.01) {
        regimeType = trendStrength > 0 ? 'UPTREND' : 'DOWNTREND';
        confidence = 0.7;
    } else if (isHighVol) {
        regimeType = 'HIGH_VOLATILITY';
        confidence = 0.6;
    } else if (isLowVol) {
        regimeType = 'CONSOLIDATION';
        confidence = 0.65;
    }
    
    return {
        type: regimeType,
        volatility: volPercentage,
        trend: trendStrength,
        confidence,
        atr: atrCurrent
    };
}

/* ---------- Adaptive Indicator Weighting ---------- */
function updateIndicatorWeights(regime, recentPerformance) {
    // Adjust weights based on market regime and historical performance
    switch (regime.type) {
        case 'STRONG_UPTREND':
        case 'STRONG_DOWNTREND':
            indicatorWeights.ma = 1.3;
            indicatorWeights.momentum = 1.4;
            indicatorWeights.rsi = 0.8;
            indicatorWeights.bb = 0.9;
            break;
        case 'HIGH_VOLATILITY':
            indicatorWeights.bb = 1.5;
            indicatorWeights.rsi = 1.2;
            indicatorWeights.ma = 0.7;
            indicatorWeights.momentum = 1.1;
            break;
        case 'CONSOLIDATION':
            indicatorWeights.bb = 1.3;
            indicatorWeights.rsi = 1.4;
            indicatorWeights.ma = 0.6;
            indicatorWeights.momentum = 0.5;
            break;
        default:
            indicatorWeights = { ma: 1.0, rsi: 1.0, bb: 1.0, momentum: 1.0, volume: 1.0 };
    }
    
    // Further refine based on recent win rate
    if (recentPerformance.winRate > 0.65) {
        // Amplify current strategy
        Object.keys(indicatorWeights).forEach(k => indicatorWeights[k] *= 1.1);
    } else if (recentPerformance.winRate < 0.45) {
        // Reduce confidence in current indicators
        Object.keys(indicatorWeights).forEach(k => indicatorWeights[k] *= 0.85);
    }
}

/* ---------- Candlestick Pattern Recognition ---------- */
function identifyCandlestickPattern(candles) {
    if (candles.length < 3) return { pattern: 'NONE', strength: 0, signal: 'NEUTRAL' };
    
    const c1 = candles[candles.length - 3];
    const c2 = candles[candles.length - 2];
    const c3 = candles[candles.length - 1];
    
    const body1 = Math.abs(c1.close - c1.open);
    const body2 = Math.abs(c2.close - c2.open);
    const body3 = Math.abs(c3.close - c3.open);
    
    const upperWick3 = c3.high - Math.max(c3.open, c3.close);
    const lowerWick3 = Math.min(c3.open, c3.close) - c3.low;
    const bodyRange3 = c3.high - c3.low;
    
    // Doji detection
    if (body3 < bodyRange3 * 0.1 && bodyRange3 > 0) {
        return { pattern: 'DOJI', strength: 0.7, signal: 'REVERSAL_PENDING' };
    }
    
    // Hammer / Inverted Hammer
    if (lowerWick3 > body3 * 2 && upperWick3 < body3 * 0.3 && c3.close > c3.open) {
        return { pattern: 'HAMMER', strength: 0.8, signal: 'BULLISH' };
    }
    if (upperWick3 > body3 * 2 && lowerWick3 < body3 * 0.3 && c3.close < c3.open) {
        return { pattern: 'SHOOTING_STAR', strength: 0.8, signal: 'BEARISH' };
    }
    
    // Engulfing patterns
    if (c2.close < c2.open && c3.close > c3.open && c3.open < c2.close && c3.close > c2.open && body3 > body2 * 1.2) {
        return { pattern: 'BULLISH_ENGULFING', strength: 0.85, signal: 'BULLISH' };
    }
    if (c2.close > c2.open && c3.close < c3.open && c3.open > c2.close && c3.close < c2.open && body3 > body2 * 1.2) {
        return { pattern: 'BEARISH_ENGULFING', strength: 0.85, signal: 'BEARISH' };
    }
    
    // Three white soldiers / Three black crows
    if (c1.close > c1.open && c2.close > c2.open && c3.close > c3.open &&
        c2.close > c1.close && c3.close > c2.close) {
        return { pattern: 'THREE_WHITE_SOLDIERS', strength: 0.9, signal: 'STRONG_BULLISH' };
    }
    if (c1.close < c1.open && c2.close < c2.open && c3.close < c3.open &&
        c2.close < c1.close && c3.close < c2.close) {
        return { pattern: 'THREE_BLACK_CROWS', strength: 0.9, signal: 'STRONG_BEARISH' };
    }
    
    return { pattern: 'NONE', strength: 0, signal: 'NEUTRAL' };
}

/* ---------- Predictive Micro-Structure Analysis ---------- */
function analyzeMicroStructure(tickBuffer, currentCandle) {
    if (tickBuffer.length < 10) return { momentum: 0, volatility: 0, prediction: 'UNCERTAIN' };
    
    const recentTicks = tickBuffer.slice(-20);
    const prices = recentTicks.map(t => t.quote);
    const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
    
    // Calculate tick momentum
    const momentum = (prices[prices.length - 1] - prices[0]) / prices[0];
    
    // Calculate micro volatility
    const variance = prices.reduce((sum, p) => sum + Math.pow(p - avgPrice, 2), 0) / prices.length;
    const microVol = Math.sqrt(variance);
    
    // Predict likely candle formation
    let prediction = 'UNCERTAIN';
    const currentBody = Math.abs(currentCandle.close - currentCandle.open);
    const currentRange = currentCandle.high - currentCandle.low;
    
    if (microVol / avgPrice > 0.001 && momentum > 0.0005) {
        prediction = 'BULLISH_CONTINUATION';
    } else if (microVol / avgPrice > 0.001 && momentum < -0.0005) {
        prediction = 'BEARISH_CONTINUATION';
    } else if (microVol / avgPrice < 0.0003) {
        prediction = 'CONSOLIDATION_LIKELY';
    } else if (currentBody < currentRange * 0.2) {
        prediction = 'DOJI_FORMING';
    }
    
    return {
        momentum,
        volatility: microVol / avgPrice,
        prediction,
        confidence: Math.min(recentTicks.length / 20, 1)
    };
}

/* ---------- Adaptive Duration Optimization ---------- */
function optimizeTradeDuration(decision, regime, volatility, pattern) {
    const baseGranularity = parseInt(granEl.value, 10);
    
    // Risk-adjusted duration based on multiple factors
    let durationMultiplier = 1.0;
    let riskScore = 0.5;
    
    // Regime-based adjustment
    switch (regime.type) {
        case 'STRONG_UPTREND':
        case 'STRONG_DOWNTREND':
            durationMultiplier = 1.5; // Hold longer in strong trends
            riskScore = 0.3;
            break;
        case 'HIGH_VOLATILITY':
            durationMultiplier = 0.7; // Shorter duration in high vol
            riskScore = 0.7;
            break;
        case 'CONSOLIDATION':
            durationMultiplier = 0.8; // Moderate duration in ranging
            riskScore = 0.6;
            break;
    }
    
    // Pattern-based adjustment
    if (pattern.strength > 0.8) {
        durationMultiplier *= 1.2; // Strong patterns justify longer holds
        riskScore *= 0.85;
    }
    
    // Volatility-based adjustment
    if (volatility > 0.015) {
        durationMultiplier *= 0.8; // Reduce duration in extreme volatility
        riskScore *= 1.2;
    } else if (volatility < 0.005) {
        durationMultiplier *= 1.1; // Can hold longer in low volatility
        riskScore *= 0.9;
    }
    
    // Confidence-based adjustment
    if (decision.confidence > 0.8) {
        durationMultiplier *= 1.15;
        riskScore *= 0.9;
    } else if (decision.confidence < 0.6) {
        durationMultiplier *= 0.85;
        riskScore *= 1.1;
    }
    
    const optimizedDuration = Math.round(baseGranularity * durationMultiplier);
    const finalDuration = Math.max(baseGranularity, Math.min(optimizedDuration, baseGranularity * 3));
    
    return {
        duration: finalDuration,
        riskScore: Math.min(riskScore, 1),
        rationale: `Optimized from ${baseGranularity}s to ${finalDuration}s (${regime.type}, Vol: ${(volatility * 100).toFixed(3)}%)`
    };
}

/* ---------- Enhanced Decision Engine ---------- */
function advancedDecisionEngine(candles) {
    if (!candles || candles.length < 50) return { action: 'HOLD', reason: 'Insufficient data', confidence: 0 };
    
    const closes = candles.map(c => c.close);
    const ma14 = calcMA(closes, 14);
    const ma50 = calcMA(closes, 50);
    const rsi = calcRSI(closes, 14);
    const bb = calcBollinger(closes, 20, 2);
    const macd = calcMACD(closes);
    const volatility = calcVolatility(closes, 20);
    const atr = calcATR(candles, 14);
    
    // Update market regime
    marketRegime = detectMarketRegime(candles);
    
    // Get recent performance
    const hist = JSON.parse(localStorage.getItem('tradeHistory') || '[]');
    const recentTrades = hist.slice(0, 20);
    const winRate = recentTrades.length > 0 ? 
        recentTrades.filter(t => t.result === 'WIN').length / recentTrades.length : 0.5;
    
    // Update indicator weights
    updateIndicatorWeights(marketRegime, { winRate });
    
    // Identify candlestick pattern
    const pattern = identifyCandlestickPattern(candles);
    
    // Micro-structure analysis
    const microAnalysis = analyzeMicroStructure(tickBuffer, candles[candles.length - 1]);
    
    const i = closes.length - 1;
    const price = closes[i];
    const prevPrice = closes[i - 1];
    const ma14Now = ma14[i];
    const ma50Now = ma50[i];
    const rsiNow = rsi[i] || 50;
    const bbNow = bb[i];
    const macdNow = macd.histogram[i];
    const atrNow = atr[i];
    
    if (ma14Now === null || rsiNow === null || !bbNow.upper) {
        return { action: 'HOLD', reason: 'Indicators not ready', confidence: 0 };
    }
    
    // Calculate weighted signals
    const trendSignal = (price > ma14Now ? 1 : -1) * indicatorWeights.ma;
    const momentumSignal = ((price - prevPrice) / prevPrice * 1000) * indicatorWeights.momentum;
    const rsiSignal = (rsiNow < 30 ? 1 : (rsiNow > 70 ? -1 : 0)) * indicatorWeights.rsi;
    const bbSignal = (price <= bbNow.lower ? 1 : (price >= bbNow.upper ? -1 : 0)) * indicatorWeights.bb;
    const macdSignal = (macdNow > 0 ? 1 : -1) * 0.8;
    
    // Pattern signal
    let patternSignal = 0;
    if (pattern.signal === 'BULLISH' || pattern.signal === 'STRONG_BULLISH') patternSignal = pattern.strength;
    if (pattern.signal === 'BEARISH' || pattern.signal === 'STRONG_BEARISH') patternSignal = -pattern.strength;
    
    // Micro-structure signal
    let microSignal = 0;
    if (microAnalysis.prediction === 'BULLISH_CONTINUATION') microSignal = 0.6;
    if (microAnalysis.prediction === 'BEARISH_CONTINUATION') microSignal = -0.6;
    
    // Composite signal
    const compositeSignal = trendSignal + momentumSignal + rsiSignal + bbSignal + 
                           macdSignal + patternSignal + microSignal;
    
    // Confidence calculation
    const signalStrength = Math.abs(compositeSignal);
    let baseConfidence = Math.min(signalStrength / 5, 1);
    
    // Adjust confidence based on regime
    baseConfidence *= marketRegime.confidence;
    
    // Adjust for pattern strength
    if (pattern.strength > 0.7) baseConfidence *= 1.15;
    
    // Adjust for recent performance
    if (winRate > 0.6) baseConfidence *= 1.1;
    else if (winRate < 0.4) baseConfidence *= 0.85;
    
    const confidence = Math.min(baseConfidence, 0.95);
    
    // Volatility filter
    if (volatility < 0.002) {
        return { 
            action: 'HOLD', 
            reason: 'Extremely low volatility - no edge', 
            confidence: 0,
            indicators: { ma14Now, ma50Now, rsiNow, bbNow, volatility, atr: atrNow, pattern, microAnalysis }
        };
    }
    
    // Decision logic with enhanced thresholds
    let action = 'HOLD';
    let reason = 'No clear signal';
    
    if (compositeSignal > 2.5 && confidence > 0.65) {
        action = compositeSignal > 4 ? 'STRONG BUY' : 'BUY';
        reason = `Bullish composite signal (${compositeSignal.toFixed(2)}) | ${marketRegime.type} | ${pattern.pattern}`;
    } else if (compositeSignal < -2.5 && confidence > 0.65) {
        action = compositeSignal < -4 ? 'STRONG SELL' : 'SELL';
        reason = `Bearish composite signal (${compositeSignal.toFixed(2)}) | ${marketRegime.type} | ${pattern.pattern}`;
    } else if (Math.abs(compositeSignal) > 1.5 && confidence > 0.7) {
        action = compositeSignal > 0 ? 'BUY' : 'SELL';
        reason = `Moderate ${compositeSignal > 0 ? 'bullish' : 'bearish'} signal with high confidence`;
    } else {
        reason = `Insufficient signal strength (${compositeSignal.toFixed(2)}) or confidence (${(confidence * 100).toFixed(0)}%)`;
    }
    
    return {
        action,
        reason,
        confidence,
        compositeSignal,
        indicators: { 
            ma14Now, ma50Now, rsiNow, bbNow, volatility, 
            atr: atrNow, macd: macdNow, pattern, microAnalysis 
        },
        regime: marketRegime,
        weights: { ...indicatorWeights }
    };
}

/* ---------- Performance Tracking ---------- */
function updatePerformanceMetrics(record) {
    if (record.result === 'WIN') performanceMetrics.wins++;
    if (record.result === 'LOSS') performanceMetrics.losses++;
    if (record.profit !== undefined) performanceMetrics.totalProfit += record.profit;
    
    performanceMetrics.regimeHistory.push({
        time: record.time,
        regime: marketRegime.type,
        result: record.result
    });
    
    // Keep last 100 regime records
    if (performanceMetrics.regimeHistory.length > 100) {
        performanceMetrics.regimeHistory.shift();
    }
}

/* ---------- Chart ---------- */
function renderChart(candles, indicators) {
    const ctx = document.getElementById('candleChart').getContext('2d');
    const labels = candles.map(c => new Date(c.epoch * 1000).toLocaleTimeString());
    const closes = candles.map(c => c.close);
    const ma14 = indicators.ma14;
    const ma50 = indicators.ma50;
    const rsi = indicators.rsi;
    const bbUpper = indicators.bb.map(b => b.upper);
    const bbMiddle = indicators.bb.map(b => b.middle);
    const bbLower = indicators.bb.map(b => b.lower);
    if (chart) chart.destroy();
    chart = new Chart(ctx, {
        data: {
            labels,
            datasets: [
                {
                    type: 'line',
                    label: 'Close',
                    data: closes,
                    borderColor: 'var(--accent-color)',
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'y',
                    borderWidth: 2
                },
                {
                    type: 'line',
                    label: 'MA(14)',
                    data: ma14,
                    borderColor: 'var(--error-color)',
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'y',
                },
                {
                    type: 'line',
                    label: 'MA(50)',
                    data: ma50,
                    borderColor: '#ff9900',
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'y',
                },
                {
                    type: 'line',
                    label: 'BB Upper',
                    data: bbUpper,
                    borderColor: 'var(--warn-color)',
                    borderDash: [6, 4],
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'y',
                },
                {
                    type: 'line',
                    label: 'BB Middle',
                    data: bbMiddle,
                    borderColor: 'var(--muted-color)',
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'y',
                },
                {
                    type: 'line',
                    label: 'BB Lower',
                    data: bbLower,
                    borderColor: 'var(--success-color)',
                    borderDash: [6, 4],
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'y',
                },
                {
                    type: 'line',
                    label: 'RSI(14)',
                    data: rsi,
                    borderColor: '#9966ff',
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'y1',
                },
            ]
        },
        options: {
            animation: false,
            plugins: {
                legend: { labels: { color: 'var(--text-color)' } }
            },
            scales: {
                x: { ticks: { color: 'var(--muted-color)' } },
                y: {
                    type: 'linear',
                    position: 'left',
                    ticks: { color: 'var(--muted-color)' },
                    grid: { color: 'var(--border-color)' }
                },
                y1: {
                    type: 'linear',
                    position: 'right',
                    ticks: { color: '#9966ff' },
                    grid: { drawOnChartArea: false },
                    min: 0,
                    max: 100
                }
            },
            responsive: true,
            maintainAspectRatio: false
        }
    });
}

/* ---------- Simulation / Live Trade Flow ---------- */
function simulateTrade(params, indicators) {
    const { confidence, compositeSignal } = params.decisionObj || { confidence: 0.5, compositeSignal: 0 };
    const volFactor = indicators.volatility * 100;
    
    // Enhanced simulation with regime-aware probability
    let baseWinChance = 0.5;
    
    // Adjust based on signal strength
    baseWinChance += (confidence * 0.25);
    baseWinChance += (Math.abs(compositeSignal) / 10);
    
    // Regime adjustment
    if (marketRegime.type.includes('STRONG')) {
        baseWinChance += 0.1;
    } else if (marketRegime.type === 'HIGH_VOLATILITY') {
        baseWinChance -= 0.05; // Harder to predict
    }
    
    // Pattern adjustment
    if (indicators.pattern && indicators.pattern.strength > 0.75) {
        baseWinChance += 0.08;
    }
    
    // Cap probability
    baseWinChance = Math.max(0.3, Math.min(0.85, baseWinChance));
    
    const win = Math.random() < baseWinChance;
    const payoutFactor = win ? (1.75 + volFactor / 10) : -1;
    const profit = params.amount * payoutFactor;
    
    const rec = {
        time: new Date().toLocaleTimeString(),
        mode: 'SIMULATION',
        symbol: params.symbol,
        amount: params.amount,
        decision: params.decision,
        result: win ? 'WIN' : 'LOSS',
        profit,
        confidence: confidence,
        regime: marketRegime.type,
        duration: params.duration
    };
    
    saveHistoryRecord(rec);
    appendFeed(`Simulated ${rec.decision} on ${rec.symbol} â†’ ${rec.result} (${profit.toFixed(2)}) [Conf: ${(confidence * 100).toFixed(0)}%]`, win ? 'success' : 'error');
    tradesMade++;
}

function requestLiveProposal(params) {
    const proposalReq = {
        proposal: 1,
        amount: params.amount,
        basis: 'stake',
        contract_type: params.contract_type,
        currency: 'USD',
        duration: params.duration,
        duration_unit: params.duration_unit,
        symbol: params.symbol,
        subscribe: 1
    };
    appendFeed(`Requesting live proposal (${params.contract_type}) for ${params.symbol} [Duration: ${params.duration}s]`, 'info');
    try {
        ws.send(JSON.stringify(proposalReq));
    } catch (e) {
        appendFeed(`Proposal request failed: ${e.message}`, 'error');
    }
}

/* ---------- Auto-trading Loop ---------- */
function startAutoTrading() {
    if (!ws || ws.readyState !== WebSocket.OPEN || !authorized) {
        appendFeed('Please connect and authorize first', 'warn');
        return;
    }
    autoTrading = true;
    startAutoBtn.disabled = true;
    stopAutoBtn.disabled = false;
    appendFeed('Auto trading activated with adaptive intelligence', 'success');
    autoCheck();
    autoTimer = setInterval(autoCheck, settings.autoInterval || AUTO_INTERVAL_MS);
}

function stopAutoTrading() {
    autoTrading = false;
    startAutoBtn.disabled = false;
    stopAutoBtn.disabled = true;
    if (autoTimer) clearInterval(autoTimer);
    appendFeed('Auto trading deactivated', 'warn');
}

async function autoCheck() {
    if (!candleData || candleData.length < 50) {
        appendFeed('Insufficient candle data for decision', 'warn');
        return;
    }
    
    const d = advancedDecisionEngine(candleData);
    
    decisionText.textContent = `${d.action} â€” ${d.reason} (Confidence: ${(d.confidence * 100).toFixed(0)}% | Signal: ${d.compositeSignal ? d.compositeSignal.toFixed(2) : 'N/A'})`;
    updateIndicatorsUI(d.indicators);
    appendFeed(`Decision: ${d.action} (${d.reason})`, 'info');

    if (d.action === 'HOLD' || d.confidence < 0.65) {
        appendFeed(`Holding position - Signal strength insufficient (Conf: ${(d.confidence * 100).toFixed(0)}%)`, 'info');
        return;
    }

    const stake = parseFloat(stakeEl.value) || 1;
    const symbol = symbolEl.value;
    const contract_type = d.action.includes('BUY') ? 'CALL' : 'PUT';
    
    // Optimize duration based on market conditions
    const durationOptimization = optimizeTradeDuration(
        d, 
        marketRegime, 
        d.indicators.volatility,
        d.indicators.pattern
    );
    
    const params = {
        amount: stake,
        symbol,
        contract_type,
        duration: durationOptimization.duration,
        duration_unit: 's',
        decision: d.action,
        decisionObj: d
    };

    appendFeed(`Trade parameters: ${contract_type} | Duration: ${durationOptimization.duration}s | ${durationOptimization.rationale}`, 'info');

    if (liveModeCheckbox.checked && confirmLiveCheckbox.checked) {
        const ok = confirm(
            `Confirm LIVE ${contract_type} on ${symbol}\n` +
            `Stake: ${stake} USD\n` +
            `Duration: ${durationOptimization.duration}s (optimized)\n` +
            `Confidence: ${(d.confidence * 100).toFixed(0)}%\n` +
            `Regime: ${marketRegime.type}\n` +
            `Pattern: ${d.indicators.pattern.pattern}\n` +
            `Risk Score: ${(durationOptimization.riskScore * 100).toFixed(0)}%`
        );
        if (!ok) {
            appendFeed('Live trade cancelled by user', 'warn');
            return;
        }
        requestLiveProposal(params);
    } else {
        simulateTrade(params, d.indicators);
    }
}

/* ---------- WebSocket and API Handling ---------- */
function connectAndAuthorize() {
    const token = tokenInput.value.trim();
    if (!token) {
        alert('Enter a valid Deriv token (demo recommended for safety)');
        return;
    }

    if (ws && ws.readyState === WebSocket.OPEN) ws.close();
    showLoading('Establishing connection to Deriv...');
    setStatus('Connecting...', 'var(--muted-color)');
    ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${APP_ID}`);

    ws.onopen = () => {
        appendFeed('WebSocket connection established', 'success');
        try {
            ws.send(JSON.stringify({ authorize: token }));
        } catch (e) {
            appendFeed(`Authorization failed: ${e.message}`, 'error');
        }
        pingTimer = setInterval(() => {
            try {
                ws.send(JSON.stringify({ ping: 1 }));
            } catch (e) {}
        }, KEEP_ALIVE_MS);
    };

    ws.onmessage = (evt) => {
        const data = JSON.parse(evt.data);

        if (data.error) {
            appendFeed(`API Error: ${data.error.message || JSON.stringify(data.error)}`, 'error');
            hideLoading();
            return;
        }

        if (data.msg_type === 'authorize' && data.authorize) {
            authorized = true;
            accountBalance = data.authorize.balance;
            updateBalanceDisplay();
            hideLoading();
            appendFeed('Authorization successful - Adaptive intelligence activated', 'success');
            fetchCandles(symbolEl.value, parseInt(granEl.value, 10));
            startAutoBtn.disabled = false;
            if (TICK_SUBSCRIPTION) subscribeToTicks(symbolEl.value);
            return;
        }

        if (data.candles) {
            candleData = data.candles;
            const now = new Date().toLocaleTimeString();
            lastUpdatedEl.textContent = `Last Updated: ${now}`;
            updateChartAndIndicators();
            appendFeed(`Candles data refreshed - Analyzing ${candleData.length} candles`, 'info');
            hideLoading();
            return;
        }

        if (data.tick) {
            // Store tick for micro-structure analysis
            tickBuffer.push({ epoch: data.tick.epoch, quote: data.tick.quote });
            if (tickBuffer.length > 50) tickBuffer.shift();
            
            const latestTick = { epoch: data.tick.epoch, close: data.tick.quote, high: data.tick.quote, low: data.tick.quote, open: data.tick.quote };
            if (candleData.length > 0 && latestTick.epoch > candleData[candleData.length - 1].epoch + parseInt(granEl.value, 10)) {
                candleData.push(latestTick);
                if (candleData.length > CANDLES_COUNT) candleData.shift();
                updateChartAndIndicators();
            }
            return;
        }

        if (data.proposal) {
            lastProposalReceived = data.proposal;
            appendFeed(`Proposal received - Ask Price: ${data.proposal.ask_price} | Payout: ${data.proposal.payout}`, 'info');
            if (liveModeCheckbox.checked && confirmLiveCheckbox.checked && data.proposal.id) {
                try {
                    ws.send(JSON.stringify({ buy: data.proposal.id, price: data.proposal.ask_price, subscribe: 1 }));
                    appendFeed(`Buy order sent for proposal ID: ${data.proposal.id}`, 'success');
                } catch (e) {
                    appendFeed(`Buy failed: ${e.message}`, 'error');
                }
            }
            return;
        }

        if (data.buy) {
            const buy = data.buy;
            const rec = {
                time: new Date().toLocaleTimeString(),
                mode: 'LIVE',
                symbol: buy.symbol,
                amount: buy.buy_price,
                decision: buy.contract_type === 'CALL' ? 'BUY' : 'SELL',
                result: 'PENDING',
                contract_id: buy.contract_id,
                profit: 0,
                regime: marketRegime.type
            };
            saveHistoryRecord(rec);
            appendFeed(`Live buy confirmed - Contract ID: ${buy.contract_id}`, 'success');
            return;
        }

        if (data.proposal_open_contract) {
            const poc = data.proposal_open_contract;
            if (poc.contract_id) {
                const hist = JSON.parse(localStorage.getItem('tradeHistory') || '[]');
                const idx = hist.findIndex(h => h.contract_id === poc.contract_id);
                if (idx >= 0) {
                    const rec = hist[idx];
                    rec.result = poc.status.toUpperCase();
                    if (poc.profit !== undefined) {
                        rec.profit = parseFloat(poc.profit);
                        accountBalance += rec.profit;
                        updateBalanceDisplay();
                    }
                    hist[idx] = rec;
                    localStorage.setItem('tradeHistory', JSON.stringify(hist));
                    renderHistory();
                    appendFeed(`Contract ${poc.contract_id} updated: ${rec.result} (${rec.profit.toFixed(2)})`, rec.profit > 0 ? 'success' : 'error');
                }
            }
            return;
        }
    };

    ws.onclose = () => {
        appendFeed('WebSocket connection closed - Attempting reconnect...', 'warn');
        setStatus('Disconnected', 'var(--muted-color)');
        authorized = false;
        hideLoading();
        clearInterval(pingTimer);
        setTimeout(() => {
            if (!authorized && tokenInput.value.trim()) {
                appendFeed('Auto-reconnecting...', 'info');
                connectAndAuthorize();
            }
        }, 5000);
    };

    ws.onerror = (err) => {
        appendFeed('WebSocket error occurred', 'error');
        hideLoading();
    };
}

/* ---------- Fetch & Subscribe ---------- */
function fetchCandles(symbol, granularity, count = CANDLES_COUNT) {
    if (!ws || ws.readyState !== WebSocket.OPEN) return appendFeed('Cannot fetch candles - WS not open', 'error');
    showLoading('Fetching historical candles...');
    const req = {
        ticks_history: symbol,
        end: 'latest',
        count,
        style: 'candles',
        granularity
    };
    try {
        ws.send(JSON.stringify(req));
    } catch (e) {
        appendFeed(`Candles request failed: ${e.message}`, 'error');
        hideLoading();
    }
}

function subscribeToTicks(symbol) {
    const req = {
        ticks: symbol,
        subscribe: 1
    };
    try {
        ws.send(JSON.stringify(req));
        appendFeed(`Subscribed to real-time ticks for ${symbol}`, 'info');
    } catch (e) {
        appendFeed(`Tick subscription failed: ${e.message}`, 'error');
    }
}

/* ---------- Update Functions ---------- */
function updateChartAndIndicators() {
    const closes = candleData.map(c => c.close);
    const ma14 = calcMA(closes, 14);
    const ma50 = calcMA(closes, 50);
    const rsi = calcRSI(closes, 14);
    const bb = calcBollinger(closes, 20, 2);
    renderChart(candleData, { ma14, ma50, rsi, bb });
    
    const indicators = {
        maNow: ma14[ma14.length - 1],
        ma50Now: ma50[ma50.length - 1],
        rsiNow: rsi[rsi.length - 1],
        bbNow: bb[bb.length - 1],
        volatility: calcVolatility(closes, 20),
        pattern: identifyCandlestickPattern(candleData),
        microAnalysis: analyzeMicroStructure(tickBuffer, candleData[candleData.length - 1])
    };
    updateIndicatorsUI(indicators);
}

function updateIndicatorsUI(indicators) {
    const maNow = indicators.maNow ? indicators.maNow.toFixed(4) : '-';
    const ma50Now = indicators.ma50Now ? indicators.ma50Now.toFixed(4) : '-';
    const rsiNow = indicators.rsiNow ? indicators.rsiNow.toFixed(2) : '-';
    const bbNow = indicators.bbNow && indicators.bbNow.middle !== null ? 
        `${indicators.bbNow.upper.toFixed(4)} / ${indicators.bbNow.middle.toFixed(4)} / ${indicators.bbNow.lower.toFixed(4)}` : '-';
    const vol = indicators.volatility ? (indicators.volatility * 100).toFixed(4) + '%' : '-';
    const pattern = indicators.pattern ? `${indicators.pattern.pattern} (${(indicators.pattern.strength * 100).toFixed(0)}%)` : '-';
    const micro = indicators.microAnalysis ? indicators.microAnalysis.prediction : '-';
    
    indList.innerHTML = `
        <li>MA(14): ${maNow} | MA(50): ${ma50Now}</li>
        <li>RSI(14): ${rsiNow}</li>
        <li>BB (U/M/L): ${bbNow}</li>
        <li>Volatility: ${vol}</li>
        <li>Pattern: ${pattern}</li>
        <li>Micro-Structure: ${micro}</li>
        <li>Regime: ${marketRegime.type} (${(marketRegime.confidence * 100).toFixed(0)}%)</li>
        <li>Weights: MA:${indicatorWeights.ma.toFixed(2)} RSI:${indicatorWeights.rsi.toFixed(2)} BB:${indicatorWeights.bb.toFixed(2)}</li>
    `;
}

/* ---------- Event Listeners ---------- */
connectBtn.addEventListener('click', () => {
    connectBtn.disabled = true;
    connectAndAuthorize();
    setTimeout(() => connectBtn.disabled = false, 2000);
});

startAutoBtn.addEventListener('click', startAutoTrading);
stopAutoBtn.addEventListener('click', stopAutoTrading);
clearHistoryBtn.addEventListener('click', clearHistory);

symbolEl.addEventListener('change', () => {
    if (ws && authorized) {
        if (tickSubscriptionId) {
            ws.send(JSON.stringify({ forget: tickSubscriptionId }));
        }
        tickBuffer = []; // Reset tick buffer for new symbol
        fetchCandles(symbolEl.value, parseInt(granEl.value, 10));
        if (TICK_SUBSCRIPTION) subscribeToTicks(symbolEl.value);
    }
});

granEl.addEventListener('change', () => {
    if (ws && authorized) {
        tickBuffer = []; // Reset tick buffer
        fetchCandles(symbolEl.value, parseInt(granEl.value, 10));
    }
});

liveModeCheckbox.addEventListener('change', () => {
    confirmLiveGroup.style.display = liveModeCheckbox.checked ? 'flex' : 'none';
    if (liveModeCheckbox.checked) {
        appendFeed('âš ï¸ LIVE MODE ENABLED - Real money at risk! Proceed with extreme caution!', 'warn');
    }
});

/* ---------- Initialization ---------- */
function init() {
    // Load persistent settings
    settings = JSON.parse(localStorage.getItem('botSettings') || '{}');
    if (settings.symbol) symbolEl.value = settings.symbol;
    if (settings.granularity) granEl.value = settings.granularity;
    if (settings.stake) stakeEl.value = settings.stake;

    // Save on changes
    symbolEl.addEventListener('change', () => { 
        settings.symbol = symbolEl.value; 
        localStorage.setItem('botSettings', JSON.stringify(settings)); 
    });
    granEl.addEventListener('change', () => { 
        settings.granularity = granEl.value; 
        localStorage.setItem('botSettings', JSON.stringify(settings)); 
    });
    stakeEl.addEventListener('input', () => { 
        settings.stake = stakeEl.value; 
        localStorage.setItem('botSettings', JSON.stringify(settings)); 
    });

    renderHistory();
    setStatus('Idle - Adaptive Intelligence Ready', 'var(--muted-color)');
    appendFeed('ðŸ¤– Enhanced Bot v2.0 initialized with Adaptive Intelligence', 'info');
    appendFeed('âœ“ IndicatorsModel: Dynamic weighting enabled', 'success');
    appendFeed('âœ“ CandlesModel: Predictive pattern recognition active', 'success');
    appendFeed('âœ“ DurationModel: Adaptive temporal optimization ready', 'success');
    appendFeed('Enter token and connect to begin trading', 'info');
}
init();

/* Expose for manual triggers */
window.fetchCandlesNow = () => fetchCandles(symbolEl.value, parseInt(granEl.value, 10));
    </script>
</body>
</html>